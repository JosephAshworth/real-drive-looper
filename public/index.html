<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Drive API Video Player</title>
  <script src="https://cdn.jsdelivr.net/npm/nosleep.js@0.12.0/dist/NoSleep.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    body {
      background: #111; color: #fff; text-align: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding: 2rem; margin: 0;
    }
    input[type="text"] {
      width: min(780px, 90%);
      padding: 0.6rem 0.8rem; font-size: 1rem;
      border-radius: 8px; border: none; outline: none;
      background:#1a1a1a; color:#fff;
    }
    .row { margin-top: 1rem; }
    .btn {
      padding: 0.6rem 1rem; margin: 0.25rem;
      background: #1db954; border: none; border-radius: 8px;
      cursor: pointer; font-weight: 600; color:#08130a;
    }
    .btn:hover { background:#17a84a; }
    #loader { display:none; margin-top: 0.75rem; }
    #error { color:#ff6b6b; margin-top: 0.75rem; min-height: 1.25rem; }
    #videoContainer {
      width: 90%; max-width: 1200px; aspect-ratio: 16 / 9;
      background: #000; margin: 1.5rem auto 0; border-radius: 12px;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      display:flex; align-items:center; justify-content:center; overflow:hidden;
    }
    video {
      width: 100%; height: 100%; object-fit: contain;
      background:#000; border-radius: 12px;
    }
    .time-grid { display:inline-grid; grid-template-columns: repeat(8, max-content); gap: 6px 8px; align-items: center; }
    .time-grid input { width: 72px; padding: 0.35rem 0.5rem; border-radius: 6px; border: none; background:#1a1a1a; color:#fff; }
    .sep { opacity: 0.6; }
    small.hint { display:block; opacity:0.7; margin-top:0.5rem; }
  </style>
</head>
<body>
  <h1>üé• Google Drive Video Player + Trimmer</h1>

  <div class="row">
    <input id="driveLink" type="text" placeholder="Paste a Google Drive link OR fileId (no need to load full video first)" />
    <button class="btn" id="playBtn">Play full video</button>
  </div>

  <div class="row">
    <div class="time-grid">
      <label for="startHours">Start</label>
      <input type="number" id="startHours"   min="0" max="23" value="0"> <span class="sep">:</span>
      <input type="number" id="startMinutes" min="0" max="59" value="0"> <span class="sep">:</span>
      <input type="number" id="startSeconds" min="0" max="59" value="0"> <span class="sep">.</span>
      <input type="number" id="startMillis"  min="0" max="999" value="0">

      <label for="endHours" style="margin-left:12px;">End</label>
      <input type="number" id="endHours"   min="0" max="23" value="0"> <span class="sep">:</span>
      <input type="number" id="endMinutes" min="0" max="59" value="0"> <span class="sep">:</span>
      <input type="number" id="endSeconds" min="0" max="59" value="0"> <span class="sep">.</span>
      <input type="number" id="endMillis"  min="0" max="999" value="0">
    </div>

    <div class="row">
      <button class="btn" id="previewBtn">Preview Trim</button>
      <button class="btn" id="downloadBtn">Download Trim</button>
      <small class="hint">Tip: whole seconds ‚Üí fastest preview; milliseconds ‚Üí precise re-encode.</small>
    </div>
  </div>

  <div id="loader">‚è≥ Working‚Ä¶</div>
  <div id="error"></div>
  <div id="videoContainer"></div>

  <script>
    // ---- Globals / state ----
    const noSleep = new NoSleep();
    let noSleepEnabled = false;
    let currentFileId = null;
    let currentVideoEl = null;
    let currentObjectUrl = null;
    let previewAbort = null;

    // ---- Helpers ----
    function extractFileId(url) {
      try {
        const patterns = [
          /\/d\/([a-zA-Z0-9_-]{25,})/,
          /id=([a-zA-Z0-9_-]{25,})/,
          /uc\?id=([a-zA-Z0-9_-]{25,})/,
        ];
        for (const p of patterns) {
          const m = url.match(p);
          if (m) return m[1];
        }
        // if they pasted a raw fileId
        if (/^[A-Za-z0-9_-]{20,}$/.test(url)) return url;
        return null;
      } catch { return null; }
    }

    function $(id) { return document.getElementById(id); }
    function setError(msg="") { $("error").textContent = msg; }
    function setLoader(show) { $("loader").style.display = show ? "block" : "none"; }

    function clampInput(id, max) {
      const el = $(id);
      let v = parseInt(el.value, 10);
      if (isNaN(v) || v < 0) v = 0;
      if (v > max) v = max;
      el.value = v;
      return v;
    }

    function formatTimeFromInputs(prefix) {
      const h  = clampInput(prefix + "Hours", 23);
      const m  = clampInput(prefix + "Minutes", 59);
      const s  = clampInput(prefix + "Seconds", 59);
      const ms = clampInput(prefix + "Millis",  999);
      const totalMs = (h * 3600 + m * 60 + s) * 1000 + ms;
      return { seconds: totalMs / 1000, ms: totalMs };
    }

    function buildTrimQuery(fileId, startT, endT, { preview = false } = {}) {
      const params = new URLSearchParams({ fileId });
      const msNonZero = (startT.ms % 1000 !== 0) || (endT.ms % 1000 !== 0);
      if (msNonZero) {
        params.set("startMs", String(startT.ms));
        params.set("endMs",   String(endT.ms));
        params.set("mode",    "precise");
      } else {
        params.set("start", String(Math.floor(startT.seconds)));
        params.set("end",   String(Math.floor(endT.seconds)));
      }
      if (preview) params.set("preview", "1");
      return `/trim?${params.toString()}`;
    }

    function getFileIdFromInput() {
      if (currentFileId) return currentFileId;
      const raw = $("driveLink").value.trim();
      const id = extractFileId(raw);
      if (id) currentFileId = id;
      return id;
    }

    // Kill previous preview/network + clean up video element & blob URL
    function cancelInFlight(reason = "new-action") {
      try { previewAbort?.abort(reason); } catch {}
      previewAbort = null;

      if (currentVideoEl) {
        try { currentVideoEl.pause(); } catch {}
        currentVideoEl.src = ""; // detach
        currentVideoEl.remove();
      }
      if (currentObjectUrl) {
        URL.revokeObjectURL(currentObjectUrl);
        currentObjectUrl = null;
      }
      $("videoContainer").innerHTML = "";
    }

    // Always create a fresh <video> so mobile browsers reset their decoders & timelines cleanly
    function mountVideo(src) {
      const v = document.createElement("video");
      v.controls = true;
      v.autoplay = true;
      v.loop = true;
      v.muted = true;        // mobile autoplay policy
      v.playsInline = true;  // iOS
      v.preload = "metadata";
      v.src = src;
      v.addEventListener("loadedmetadata", () => { /* ready to scrub */ }, { once: true });
      $("videoContainer").appendChild(v);
      currentVideoEl = v;

      // Unmute on first gesture
      const enable = () => { v.muted = false; v.play().catch(()=>{}); document.removeEventListener("click", enable); };
      document.addEventListener("click", enable);
    }

    // ---- Play full video (optional) ----
    async function loadVideo() {
      setError("");
      cancelInFlight();

      const id = getFileIdFromInput();
      if (!id) { setError("‚ö†Ô∏è Paste a Google Drive link or file ID first."); return; }

      // HEAD check
      setLoader(true);
      try {
        const metaRes = await fetch(`/video/${id}`, { method: "HEAD", cache: "no-store" });
        if (!metaRes.ok) throw new Error("Video not accessible");
      } catch (e) {
        setLoader(false);
        setError("‚ùå " + e.message);
        return;
      }

      setLoader(false);
      mountVideo(`/video/${id}`);
      if (!noSleepEnabled) { noSleep.enable(); noSleepEnabled = true; }
    }

    // ---- Preview Trim (no need to load full video first) ----
    async function previewTrim() {
      setError("");
      cancelInFlight(); // stop any previous preview/stream

      const id = getFileIdFromInput();
      if (!id) { setError("‚ö†Ô∏è Paste a Google Drive link or file ID first."); return; }

      const startT = formatTimeFromInputs("start");
      const endT   = formatTimeFromInputs("end");
      if (endT.ms <= startT.ms) { setError("‚ö†Ô∏è End time must be after start time."); return; }

      setLoader(true);

      // Prepare body ‚Äì only send ms when they matter
      const msNonZero = (startT.ms % 1000 !== 0) || (endT.ms % 1000 !== 0);
      const body = { fileId: id, preview: true };
      if (msNonZero) {
        body.startMs = startT.ms; body.endMs = endT.ms; body.mode = "precise";
      } else {
        body.start = Math.floor(startT.seconds); body.end = Math.floor(endT.seconds);
      }

      // Make an abortable request
      previewAbort = new AbortController();
      const { signal } = previewAbort;

      try {
        const res = await fetch("/trim", {
          method: "POST",
          headers: { "Content-Type": "application/json", "Accept": "application/json" },
          cache: "no-store",
          body: JSON.stringify(body),
          signal
        });

        setLoader(false);
        if (!res.ok) throw new Error("Trim failed");

        const ct = res.headers.get("content-type") || "";
        let src;
        if (ct.includes("application/json")) {
          const data = await res.json();
          if (!data?.url) throw new Error("Missing preview URL");
          src = data.url; // Range-enabled; best scrubbing
        } else if (ct.startsWith("video/")) {
          const blob = await res.blob();
          src = currentObjectUrl = URL.createObjectURL(blob);
        } else {
          throw new Error("Unexpected response type");
        }

        mountVideo(src);
        if (!noSleepEnabled) { noSleep.enable(); noSleepEnabled = true; }
      } catch (err) {
        if (err?.name === "AbortError") return; // canceled by us‚Äîignore
        setLoader(false);
        setError("‚ùå " + err.message);
      }
    }

    function downloadTrim() {
      setError("");
      const id = getFileIdFromInput();
      if (!id) { setError("‚ö†Ô∏è Paste a Google Drive link or file ID first."); return; }

      const startT = formatTimeFromInputs("start");
      const endT   = formatTimeFromInputs("end");
      if (endT.ms <= startT.ms) { setError("‚ö†Ô∏è End time must be after start time."); return; }

      const url = buildTrimQuery(id, startT, endT, { preview: false });
      window.location.href = url; // browser download
    }

    // ---- Wiring & lifecycle ----
    $("playBtn").addEventListener("click", loadVideo);
    $("previewBtn").addEventListener("click", previewTrim);
    $("downloadBtn").addEventListener("click", downloadTrim);

    // Clamp all time inputs
    ["startHours","startMinutes","startSeconds","startMillis",
     "endHours","endMinutes","endSeconds","endMillis"].forEach(id => {
      $(id).addEventListener("input", () => {
        const max = id.includes("Hours") ? 23 : id.includes("Millis") ? 999 : 59;
        clampInput(id, max);
      });
    });

    // Abort/cleanup on page hide or unload (stops previous preview still loading on refresh)
    window.addEventListener("beforeunload", () => cancelInFlight("unload"));
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") cancelInFlight("hidden");
    });
  </script>
</body>
</html>
